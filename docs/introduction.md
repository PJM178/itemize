# Introduction

## Conception and Origin

After several hectic attempts to develop software for the startup scenery in order to start a business using the newfound ideas of ReactJS and the new stacks that could be tighly integrated in order to build amazing custom software I found myself failing, unable to deliver a product in time and with the constant pressures and deadlines; not to add the constant pivoting and change, bad management and ridiculous requeriments, I started wondering, what can be done in order to relieve all this pressure? In order to be able to ship a product using these powerful technologies without having to deal with the drawbacks and expenses, as well as to prevent the code turning into a rolling pile of mud.

I saw a lot of business turning into huge investment rounds, in order to ship what was esencially an average product; and these rounds were achieved by great sales people, not by the quality of the product itself, which leaves behind a lot of ideas that are not taken even to a MVP stage; most mere mortals, aspiring app developers cannot afford any of this.

Some ideas came into mind, and eventually I bundled them all together; take the most popular existing technologies and paradigms, keep in mind what effect these would have in the team that is using them because code does not exist in a vacuum, keep in mind the rookie, the designer, the annoying manager that keeps pushing for changes; take all these, all these ideas, and combine them, into one single thing, "a stack of stacks", an system where ideas, every concepts and properties can take the shape of an item in an schema, everything is an item, "Itemize".

I realized that while itemizing might not work for all projects, it will work for most; and as such I started developing.

### The team

Teams can follow the paradigm of choice, waterfall, agile, kanban; Itemize is not here to define how a team is managed and how relationships are set within the team, but it is here to set a dynamic of development; one of clear, very defined roles.

The text type and its extensive specification when set as templating mode for instance was created to create a separation of programming and designing duties, many times in many teams, there has to be an agreement between a designer and a programmer about how the application is to be designed; but itemize text type was designed in order to be able to define a "design" that a programmer can take as a template.

This means, that designers will go to the CMS and design templates within the application itself in the CMS editor; and the programmer can import these templates and use them, these templates are tightly integrated and can be edited in real time, UI/UX programming meetings can then be reduced, the designers can even hotfix designs in production builds without any input from the programmer, and UI/UX folks can focus on their job, so do programmers.

### Focus on the product

Itemize tries to be extremely simple, even if it comes out as unusual, it should be easy to understand what is going on. Programming teams have to often switch focus to technical issues, documentation, Q&A, testing, rather than dealing with what the client sees and values; budget and time that is allocated into those other tasks is of little value to the user, and very often is neglected by management; this causes the huge disconnect that exists within the direction of the team to get the product shipped and the fact that code quality is necessary for the life of the product. This is a huge expense.

Itemize takes a whole different approach regarding this, which is why it tries to be simple, and strict; even the most awful itemize code should be rather understandable (unless you have some form of special talent), there's also a huge focus on what the user sees, just get the thing shipped, make the users happy.

Of course itemize is not a simple technology on itself, as a stack of stacks it requires understanding of all the underlying aspects of it, such as ReactJS, postgreSQL, redis, websockets, etc... but for a programmer that holds these skills; itemize should be easy to understand. Without having to worry about how things link together, the only bugs and issues that should concern the developer are those that the user can see.

And so we align the interests of management, programming and the user.

### Flexibility because startups fail

"Fail Fast, Fail Often", the idea of itemize was born out of failure, not only that is the reason why it wants things to get done quickly so ideas can be tested, but also why it enables you to pivot. Reusing old itemize code is simple because it uses the same base, old designs, old renderers, they can all be taken into a new project rather easily.

Change tolerance is also within its core, requeriments change all the time and it's important for that to be enabled, in Itemize it is as simple as changing the schema to reflect the new structure and modifying the code of the views that use it; database changes can often be automatic.

### Separation of Infrastructure and Opensource

I would consider itemize to be a form of software infraestructure, and as such it is separated from the application itself and can be updated, upgraded, security patches can come in, and you get all these to your infraestucture, so if anyone running any project with itemize finds an issue and decides to fix it, or develops a feature for it, you access it as well.

Not only that but you have hold of this infraestructure, and you can be free to modify or adapt it to fit your needs; this is unlike any other similar infraestructure technologies of the market nowadays that are sold as a service, itemize is free, opensource; and it uses that to leverage and create value not just for itemize itself, but for you as a developer using it.

It is the way to compete, at its core what I want to enable is that anyone, regardless of their background, country of origin, or budget, can develop an app; and compete based on their idea, not on the technology; to shake the market.
SITE
. Update password function [+4] [DONE]
. Public profile [+5] [DONE]
. Location [+3] [DONE]
. The first user to sign in is admin [+1] [NO, USE DATABASE]
. Role picker for admins in public profile [+2] [DONE]
. About me in profile [+5] [DONE]
. Implementation of CMS module [+10] [DONE]
. Fix redis synchronization bug [+1] [DONE]
. Rich Text Editor Raw Mode [+2] [DONE]
. Fix bug where invalid link appears
. Implementation of Forum module [+7]
. Implementation of mailing module [+7]
. Test implementation of a sales module for probing includes [+20]
. String based total search (tags?) [+10] [DONE?]

ONZASYSTEMS [+3]
. Build a Frontpage with few details
  . en
  . es
  . fi
  . ru
  . de

CYCLINGEXCHANGEHUB [+10]
. Build Initial Frontpage
. Bicycle Module

RIDINGEXCHANGE [+5]
. Build Initial Frontpage
. Horse Module

EXTRA (LOW PRIORITY)
. Implementation of flagging
. Bans and Blocks

SEO (LOWEST PRIORITY) [DONE]
1. SSR Implementation via constructor and SSR rules, SSR rules will be rules specific to an url
  0. Only public data, user specific data can be loaded client side
  1. TOKEN, ID, ROLE, LANG, etc... all localstorage data is sent via cookie to create a fakeStorage where info can be fetch (maybe not render these)
  2. Routes must have their own SSR rules, these SSR rules allow to set the variable global.DATA that acts as endpoint
  for initial fetching for data hydration, somehow this data must be accessible as well on the server side, where lifecycles
  do not get hit
  3. SSR rules will have their own way to set the title as well as description and other SEO tags
  4. SlowLoadingComponent must be immediate and be immediately ready on server contexts
  5. manifest and html set via the SSR rules
  6. SSR rules should be able to load resources as well

TECH (HAPPENS AS IT GOES)
. Fix floating point imprecision in lat/lng by adding an id to location by smashing lat and lng in the server side that way
equality can be checked; implement in geocode/search and autocomplete and whatnot; check in preferences by updating twice a manual pick [DONE]

. Version searches, searches limited by a version type

. Add limit and offset to the search
  . Implement by using a maxMatchPageSize required property on the item definition itself, very large values
  are expected on the transactional mode, whereas smaller values for traditional
  . Change the result from the ISearchResult[] and its name to ISearchMatch to have a totalCount property so that the offset limiter traditional
  usage can actually apply
  . Add the property traditional to the search in order to return actual results and be more straightforward
    traditional results must be smaller
  . it provides a list of all the matched search results
  . its result set is finite the max results it can give are given by maxMatchPageSize
  . it also will return a count to be consistent in order to know if there has been data loss to this search type
  . is able to keep itself realtime or not, in main searches you wouldn't want it be realtime
  . will support cache policies created and parent which means that the search can mantain itself in realtime and be able
    to cache itself client side and even keep itself updated
  . really bad if there's no cache support client side as it will be very slow
  . will also support offset and limit as well we might be able to append more search
    results to giant sets if the user decides to fetch even more of them

. Revamp currency to have a normalized_value in dollars
. Revamp currency search to use normalized_value on mismatch or the value on match
. Maybe download a list of base conversions from https://free.currencyconverterapi.com/ automatically every day
. Currencies ["EEK", "LTL", "GWP"] not supported in API all others supported, these currencies are not in the country list
so can safely be removed
. Create sqlMantenience for mantenience of mutable values like this in the type

. Image support in rich text [DONE]
. File support in rich text
. Youtube/Vimeo support in rich text

. taglist (predefined tags)
. list of string
. Array in SQL
. maxtags optional as maxlenght
. mintags optional as minlenght

. Add a storage location mapper [DONE]
  . every object once added gets set a storage server id, these are set by region ids or whatever, any identifier works
  . every one of these identifiers gets its own openstack config in the sensitive config
  . every one of these identifiers gets a uploads hostname in the standard config
  . these id is stored as storage_id in the table and it can be set by the client during add but it's readonly after that
  . in order for the client to choose which storage_id it wants, we need in the standard config a location mapper, for that we need
  country code combinations and the storage_id to be used, and a default for the rest